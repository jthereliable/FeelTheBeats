require "coffee-script"

__      = require("underscore")
mysql   = require("database/mysql")
mongo   = require("database/mongo")
squel   = require("squel")
async   = require("async")

collection = {}
model = {}

FIELD_SPLIT = /[\;\,]\s{0,1}/g
OPERATORS = {
  $gt:    ">"
  $gte:   ">="
  $lt:    "<"
  $lte:   "<="
  $ne:    "!="
  $like:  "LIKE"
}

collection.get = (req, from, where, fields, limit=25, callback) ->
  keys = __.keys(fields)
  allowed = __.union req.query?.fields?.split(FIELD_SPLIT), req.body?.fields?.split(FIELD_SPLIT)
  ignore = __.union req.query?.ignore?.split(FIELD_SPLIT), req.body?.ignore?.split(FIELD_SPLIT)
  params = __.extend __.pick(req.query, keys), __.pick(req.body, keys), __.pick(req.params, keys)

  order = req.query.order
  sort = req.query.sort

  offset = req.query.offset|0 || 0
  limit = req.query.limit|0 || limit

  if offset < 0
    offset = 0
  if limit < 1
    limit = 1
  if limit > 50
    limit = 50

  if order?
    if !__.has(fields, order) || fields[order].sort == null
      order = null
  if !order?
    for o, v of fields
      if v.default_order
        order = o
        break
  sort ?= fields[order].sort
  sort = !(sort==-1 || String(sort).toUpperCase() == "DESC")

  sql = squel.select()
              .from(
                mysql.escapeId(from)
              ).order(
                mysql.escapeId(fields[order].name || "#{from}.#{order}"),
                sort
              ).offset(offset)
              .limit(limit);
  count_sql = squel.select()
                    .field("COUNT(*)", "count")
                    .from(
                      mysql.escapeId(from)
                    )

  joined = {}
  for k in keys
    f = fields[k]
    if !f.unignoreable && ((f.ignore && allowed.indexOf(k) == -1) || ignore.indexOf(k) != -1 || (k.indexOf(".")>-1 && ignore.indexOf(k.split(".",1)[0]) != -1) || f.collection)
      continue
    if f.tables?
      for t in f.tables
        if __.isArray(t.table)
          t0 = t.table[0]
          t1 = t.table[1]
        else
          t0 = t.table
          t1 = null
        if !joined[t0]?
          sql.left_join(
            mysql.escapedId(t0),
            mysql.escapeId(t1),
            mysql.escapeId(t.on[0]) + " = " + mysql.escapeId(t.on[1])
          )
          if f.queryable && __.has(params, k)
            count_sql.left_join(
              mysql.escapeId(t0),
              t1,
              mysql.escapeId(t.on[0]) + " = " + mysql.escapeId(t.on[1])
            );
          joined[t0] = true
    fn = mysql.escapeId(f.name ? "#{from}.#{k}")
    sql.field(fn, k)
    if f.queryable && __.has(params, k)
      if f.type == "string"
        sql.where("#{fn} LIKE " + mysql.escape(params[k] + "%"));
        count_sql.where("#{fn} LIKE " + mysql.escape(params[k] + "%"));
      else
        sql.where("#{fn} = " + mysql.escape(params[k]));
        count_sql.where("#{fn} = " + mysql.escape(params[k]));

  for i,v of where
    fn = if i.indexOf "." == -1 then "#{from}.#{i}" else i
    if __.isObject(v)
      op = __.keys(v)[0]
      v = v[op]
      op = OPERATORS[op]
    else
      op = "="
    sql.where(mysql.escapeId(fn) + " #{op} " + mysql.escape(v))
    count_sql.where(mysql.escapeId(fn) + " #{op} " + mysql.escape(v))

  sql = sql.toString()
  count_sql = count_sql.toString()

  out = {}
  async.parallel [
    (next) ->
      mysql.query sql, (err, rows) ->
        if err?
          next(err)
          return
        out.collection = rows
        next()
    (next) ->
      mysql.query count_sql, (err, rows) ->
        if err?
          next(err)
          return
        out.count = {
          total: rows[0].count
          offset
          limit
        }
        next()
  ], (err) ->
    if err?
      callback? err, null
      return
    callback null, out
  null

model.get = (req, from, where, fields, callback) ->
  keys = __.keys(fields)
  allowed = __.union req.query?.fields?.split(FIELD_SPLIT), req.body?.fields?.split(FIELD_SPLIT)
  ignore = __.union req.query?.ignore?.split(FIELD_SPLIT), req.body?.ignore?.split(FIELD_SPLIT)

  sql = squel.select().from(mysql.escapeId(from))
  nosql = {}

  joined = {}
  for k in keys
    f = fields[k]
    if !f.unignoreable && ((f.ignore && allowed.indexOf(k) == -1) || ignore.indexOf(k) != -1 || (k.indexOf(".")>-1 && ignore.indexOf(k.split(".",1)[0]) != -1) || f.collection)
      continue
    if f.collection?
      if !nosql[f.collection]?
        nosql[f.collection] = []
      nosql[f.collection].push {
        key: k
        name: f.name ? k
      }
      continue
    if f.tables?
      for t in f.tables
        if __.isArray(t.table)
          t0 = t.table[0]
          t1 = t.table[1]
        else
          t0 = t.table
          t1 = null
        if !joined[t0]?
          sql.left_join(
            mysql.escapedId(t0),
            mysql.escapeId(t1),
            mysql.escapeId(t.on[0]) + " = " + mysql.escapeId(t.on[1])
          )
          joined[t0] = true
    fn = mysql.escapeId(f.name ? "#{from}.#{k}")
    sql.field(fn, k)

  for i,v of where
    fn = if i.indexOf "." == -1 then "#{from}.#{i}" else i
    if __.isObject(v)
      op = __.keys(v)[0]
      v = v[op]
      op = OPERATORS[op]
    else
      op = "="
    sql.where(mysql.escapeId(fn) + " #{op} " + mysql.escape(v))

  sql = sql.toString()
  out = null
  async.series [
    (next) ->
      mysql.query sql, (err, rows) ->
        if err?
          callback? err, null
          return
        if rows.length == 0
          callback? null, {}
          return
        out = rows[0]
        next()
    (next) ->
      async.eachSeries __.keys(nosql), (collection, next) ->
        mongo.collection(collection).find where, (err, docs) ->
          if err
            next(err)
            return
          if docs.length == 0
            next()
            return
          doc = docs[0]
          f = nosql[collection]
          for v in f
            out[v.key] = doc[v.name]
          next()
      , (err) ->
        if(err)
          callback? err, null
          return
        next()
    (next) ->
      callback? null, out
  ]

exports.collection = collection
exports.model = model